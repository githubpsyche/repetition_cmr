# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/analyses/Spacing_Effect.ipynb (unless otherwise specified).

__all__ = ['recall_probability_by_lag', 'df_recall_probability_by_lag']

# Cell

from numba import njit, prange
import numpy as np

@njit(nogil=True, parallel=True)
def recall_probability_by_lag(study_positions_in_recall_order, presentations, max_lag=8):

    total_presented, total_retrieved = np.zeros(max_lag+2), np.zeros(max_lag+2)

    for trial_index in prange(len(presentations)):

        # nested accumulation to ensure parallelization doesn't cause problems
        presented, retrieved = np.zeros(max_lag+2), np.zeros(max_lag+2)

        # extract sequence of presentations
        presentation = presentations[trial_index]

        # extract sequence of responses
        responses = study_positions_in_recall_order[trial_index]
        responses = responses[responses > 0]-1

        # for each studied_item in presentation, identify its presentation positions
        for studied_item in np.unique(presentation):

            # identify occurrences of item index in presentation vector
            item_occurrences = np.where(presentation == studied_item)[0]

            # convert to incremental distances
            lags = item_occurrences[1:] - item_occurrences[:-1]

            # aggregate to select bin for accumulation
            index = 0 if lags.size == 0 else np.int64(np.mean(lags))

            # accumulate
            presented[index] += 1
            retrieved[index] += item_occurrences[0] in responses

        total_presented += presented
        total_retrieved += retrieved

    return total_retrieved/total_presented

# Cell

import pandas as pd

def df_recall_probability_by_lag(trials, presentations, subject_count, trial_count, max_lag=8):

    lags = ['N/A', '0', '1-2', '3-5', '6-8']
    result = {'subject': [], 'lag': [], 'prob': []}

    for subject in range(subject_count):

        subject_result = recall_probability_by_lag(
            trials[subject*trial_count:(subject+1)*trial_count], presentations[subject*trial_count:(subject+1)*trial_count], max_lag)

        binned = np.zeros(5)
        binned[0] = subject_result[0]
        binned[1] = subject_result[1]
        binned[2] = (subject_result[2] + subject_result[3])/2
        binned[3] = (subject_result[4] + subject_result[5] + subject_result[6])/3
        binned[4] = (subject_result[7] + subject_result[8] + subject_result[9])/3

        result['subject'] += [subject+1]*len(lags)
        result['lag'] += lags
        result['prob'] += binned.tolist()

    return pd.DataFrame(result)